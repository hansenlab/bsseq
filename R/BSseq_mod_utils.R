chrSelectBSseq_mod <- function(BSseq_mod, seqnames = NULL, order = FALSE) {
    if (!is.null(seqnames)){seqlevels(BSseq_mod) <- seqnames
        if (order) {BSseq_mod <- orderBSseq_mod(BSseq_mod, seqOrder = seqnames)}
    }
    BSseq_mod
}

orderBSseq_mod <- function(BSseq_mod, seqOrder = NULL) {
    if (!is.null(seqOrder)) {
        seqlevels(BSseq_mod, pruning.mode = "coarse") <- seqOrder
    }
    BSseq_mod[order(granges(BSseq_mod))]
}

getMeth_mod <- function(BSseq_mod, regions = NULL, type = c("smooth", "raw"),
                    what = c("perBase", "perRegion"), confint = FALSE,
                    alpha = 0.95, withDimnames = TRUE) {
    p.conf <- function(p, n, alpha) {
        z <- abs(qnorm((1 - alpha)/2, mean = 0, sd = 1))
        upper <- (p + z ^ 2 / (2 * n) +
                      z * sqrt((p * (1 - p) + z ^ 2 / (4 * n)) / n)) /
            (1 + z ^ 2 / n)
        lower <- (p + z ^ 2 / (2 * n) -
                      z * sqrt((p * (1 - p) + z ^ 2 / (4 * n)) / n)) /
            (1 + z ^ 2 / n)
        return(list(meth = p, lower = lower, upper = upper))
    }

    stopifnot(is(BSseq_mod, "BSseq_mod"))
    type <- match.arg(type)
    if (type == "smooth" & !hasBeenSmoothed_mod(BSseq_mod)) {
        stop("'type=smooth' requires the object to have been smoothed.")
    }
    what <- match.arg(what)
    if (what == "perRegion" & is.null(regions)) {
        stop("'what=perRegion' but no 'regions' supplied")
    }
    z <- abs(qnorm((1 - alpha)/2, mean = 0, sd = 1))
    if (is.null(regions) && type == "smooth") {
        coef <- getBSseq_mod(BSseq_mod, "coef", withDimnames)
        meth <- getBSseq_mod(BSseq_mod, "trans", withDimnames)(coef)
        if (confint) {
            upper <- meth + z * getBSseq_mod(BSseq_mod, "se.coef", withDimnames)
            lower <- meth - z * getBSseq_mod(BSseq_mod, "se.coef", withDimnames)
            return(list(meth = meth, lower = lower, upper = upper))
        } else {
            return(meth)
        }
    }
    if (is.null(regions) && type == "raw") {
        cov <- getBSseq_mod(BSseq_mod, "U", withDimnames) +
            getBSseq_mod(BSseq_mod, "M", withDimnames) +
            getBSseq_mod(BSseq_mod, "Other_mod", withDimnames)
        meth <- getBSseq_mod(BSseq_mod, "M", withDimnames) / cov
        if (confint) {
            return(p.conf(meth, cov, alpha))
        } else {
            return(meth)
        }
    }

    ## At this point, regions have been specified
    if (is(regions, "data.frame")) {
        regions <- data.frame2GRanges(regions)
    }
    stopifnot(is(regions, "GenomicRanges"))
    if (confint) {
        stop("'confint = TRUE' is not supported by 'getMeth' when regions is given")
    }
    grBSseq <- granges(BSseq_mod)
    ov <- findOverlaps(grBSseq, regions)
    # NOTE: This realises a large object in memory (`meth`) - could do it in
    #       chunks if what = perRegion
    if (type == "smooth") {
        meth <- as.matrix(
            getBSseq_mod(BSseq_mod, "trans", withDimnames)(
                getBSseq_mod(BSseq_mod, "coef", withDimnames))[
                    queryHits(ov), , drop = FALSE])
    } else if (type == "raw") {
        cov <- getBSseq_mod(BSseq_mod, "U", withDimnames) +
            getBSseq_mod(BSseq_mod, "M", withDimnames) +
            getBSseq_mod(BSseq_mod, "Other_mod", withDimnames)
        meth <- as.matrix(
            (getBSseq_mod(BSseq_mod, "M", withDimnames) / cov)[
                     queryHits(ov), , drop = FALSE])
    }
    out <- lapply(split(meth, subjectHits(ov)), matrix, ncol = ncol(meth))
    if (what == "perBase") {
        # TODO: Don't really understand the logic of the remaining code; how
        #       could the results end up in the wrong order wrt to regions?
        outList <- vector("list", length(regions))
        outList[as.integer(names(out))] <- out
        return(outList)
    } else if (what == "perRegion") {
        out <- do.call(rbind, lapply(out, colMeans2, na.rm = TRUE))
        # TODO: Don't really understand the logic of the remaining code; how
        #       could the rows end up in the wrong order?
        outMatrix <- matrix(NA, ncol = ncol(BSseq_mod), nrow = length(regions))
        if (withDimnames) colnames(outMatrix) <- sampleNames(BSseq_mod)
        outMatrix[as.integer(rownames(out)), ] <- out
        outMatrix
    }
}


getCoverage_mod <- function(BSseq_mod, regions = NULL, type = c("Cov", "M"),
                        what = c("perBase", "perRegionAverage",
                                 "perRegionTotal"),
                        withDimnames = TRUE) {
    stopifnot(is(BSseq_mod, "BSseq_mod"))
    type <- match.arg(type)
    what <- match.arg(what)
    if (is.null(regions)) {
        if (type == "Cov") {
            if (what == "perBase") {
                return((getBSseq_mod(BSseq_mod, "U", withDimnames) +
                           getBSseq_mod(BSseq_mod, "M", withDimnames) +
                           getBSseq_mod(BSseq_mod, "Other_mod", withDimnames)))
            }
            if (what == "perRegionTotal") {
                return(colSums2((getBSseq_mod(BSseq_mod, "U", withDimnames) +
                                     getBSseq_mod(BSseq_mod, "M", withDimnames) +
                                     getBSseq_mod(BSseq_mod, "Other_mod", withDimnames))))
            }
            if (what == "perRegionAverage") {
                return(colMeans2((getBSseq_mod(BSseq_mod, "U", withDimnames) +
                                      getBSseq_mod(BSseq_mod, "M", withDimnames) +
                                      getBSseq_mod(BSseq_mod, "Other_mod", withDimnames))))
            }
        } else {
            if (what == "perBase") {
                return(getBSseq_mod(BSseq_mod, type, withDimnames))
            }
            if (what == "perRegionTotal") {
                return(colSums2(getBSseq_mod(BSseq_mod, type, withDimnames)))
            }
            if (what == "perRegionAverage") {
                return(colMeans2(getBSseq_mod(BSseq_mod, type, withDimnames)))
            }
        }
    }
    if (is(regions,  "data.frame")) {
        regions <- data.frame2GRanges(regions)
    }
    stopifnot(is(regions, "GenomicRanges"))
    grBSseq <- granges(BSseq_mod)
    ov <- findOverlaps(grBSseq, regions)
    if (type == "Cov"){
        coverage <- (getBSseq_mod(BSseq_mod, "U", withDimnames) +
                         getBSseq_mod(BSseq_mod, "M", withDimnames) +
                         getBSseq_mod(BSseq_mod, "Other_mod", withDimnames))[
                             queryHits(ov), , drop = FALSE]
    } else {
        coverage <- getBSseq_mod(BSseq_mod, "M", withDimnames)[
            queryHits(ov), , drop = FALSE]
    }
    out <- lapply(split(coverage, subjectHits(ov)), matrix,
                  ncol = ncol(coverage))

    if (what == "perBase") {
        # TODO: Don't really understand the logic of the remaining code; how
        #       could the results end up in the wrong order wrt to regions?
        outList <- vector("list", length(regions))
        outList[as.integer(names(out))] <- out
        return(outList)
    } else if (what == "perRegionAverage") {
        out <- do.call(rbind, lapply(out, colMeans2, na.rm = TRUE))
    } else if (what == "perRegionTotal") {
        out <- do.call(rbind, lapply(out, colSums2, na.rm = TRUE))
    }
    # TODO: Don't really understand the logic of the remaining code; how
    #       could the rows end up in the wrong order?
    outMatrix <- matrix(NA, ncol = ncol(BSseq_mod), nrow = length(regions))
    if (withDimnames) colnames(outMatrix) <- sampleNames(BSseq_mod)
    outMatrix[as.integer(rownames(out)), ] <- out
    outMatrix
}
